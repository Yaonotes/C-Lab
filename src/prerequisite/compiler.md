# Compiler

There are generally two types of programming languages if we categorize them by how they are executed by the computer:

* Compiled Languages: Computers will first translate the whole source code to machine code, then the computers will directly execute the machine code.
* Interpreted Languages. Computers will read and execute the code line by line.

However, these two concepts are somehow vague for two reasons:

* Theoretically, every language can be implemented in two ways. The types of running does not depend on the language itself, but on how the compiler executes them.
* Some languages are executed in a fusion manner. For example, the programs written in Java will be first compiled into an intermediate form ([bytecode](https://en.wikipedia.org/wiki/Bytecode)), and then executed line by line.

Nevertheless, it is good to know that there are different ways in executing the program. In the following parts, we will use `gcc 8.3` as the default compiler.

## Compile a Single Source File

Assume we wrote a simple program that only prints the `Hello World` to the console, as below:

#### **`simple.c`**
``` c
{{#include ../../code/compiler/simple.c}}
```

We can then compile the source coed into an executable with the command: 

```gcc simple.c -o simple.run```

Then we could run the executable file by ```./simple.run``` and the program will print the `Hello World` to the console. Here we learned the simplest command with our compiler:

* The filename is considered as the input file of our compiler. It is passed to the compiler without any parameters.
* The parameter `-o` specifies the output executable file name.

# Compile Multiple Files

After compiling the single source file, you may want to know what if there are multiple files, including headers? Assume we have an example as below:

#### **`main.c`**
``` c
{{#include ../../code/compiler/main.c}}
```
#### **`header.h`**
``` c
{{#include ../../code/compiler/header.h}}
```
#### **`header.c`**
``` c
{{#include ../../code/compiler/header.c}}
```

If there are multiple files, we must explicitly tell the compiler where to look for other source files. In this case, our mail program is defined by `main.c` and it calls a function defined and implemented in `header.c`. We could run 

`
gcc main.c header.c -o main.run
`

## What Happened during Compilation

In order to know what happened during the compilation, we could force our compiler save the intermediate results by running the following command:

`
gcc main.c -save-temps -o main.run
`

We found there are several intermediate temp files generated by our compiler:

* `simple.i`. We can read this file in our text editor. The `.i` file is generated after **preprocessing**, which handles the preprocessors, like `#include`, `#define`, etc. For different preprocessors, our compiler will perform different tasks:
  
  * `#include`: the compiler will replace the directives with the content of the specified file.
  * `#define`: the compiler will replace the macros.
  * `#if`, `#if def` and `#ifndef`: the compiler will select different portions of the texts.

* After this step, the compiler will transform the preprocessed file into an abstract syntax tree (AST). This stage is responsible for generating most of the compiler warnings as well as parse errors

* `simple.bc` and `simple.s`. The compiler then translate the AST into low-level intermediate code, `simple.bc`. Then the intermediate code will be translated into machine code `simple.s`. This phase is responsible for optimizing the generated code and handling target-specific code generation.

* `simple.o`. Assembler (part of the compiling toolchain), at this stage, will translate the machine code into a target object file.
  
* `simple.run`. This stage, the linker (part of the compiling toolchain) merge multiple object files into an executable file.

## C and C++ Compilers

Essentially, C++ is a superset of C that includes some object-oriented features. Other than that, C is also slightly faster than C++. There might be some differences in the header files, but you can usually find alternatives in both two languages.